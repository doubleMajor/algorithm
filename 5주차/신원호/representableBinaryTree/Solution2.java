/**
 * 당신은 이진트리를 수로 표현하는 것을 좋아합니다.
 *
 * 이진트리를 수로 표현하는 방법은 다음과 같습니다.
 *
 * 이진수를 저장할 빈 문자열을 생성합니다.
 * 주어진 이진트리에 더미 노드를 추가하여 포화 이진트리로 만듭니다. 루트 노드는 그대로 유지합니다.
 * 만들어진 포화 이진트리의 노드들을 가장 왼쪽 노드부터 가장 오른쪽 노드까지, 왼쪽에 있는 순서대로 살펴봅니다. 노드의 높이는 살펴보는 순서에 영향을 끼치지 않습니다.
 * 살펴본 노드가 더미 노드라면, 문자열 뒤에 0을 추가합니다. 살펴본 노드가 더미 노드가 아니라면, 문자열 뒤에 1을 추가합니다.
 * 문자열에 저장된 이진수를 십진수로 변환합니다.
 * 이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다.
 *
 * 일단 미친놈인게 이진트리를 수로 표현하는걸 좋아하는게 말이 안됨
 *
 * 문제 :
 * 당신은 수가 주어졌을때, 하나의 이진트리로 해당 수를 표현할 수 있는지 알고 싶습니다.
 * 이진트리로 만들고 싶은 수를 담은 1차원 정수 배열 numbers가 주어집니다. numbers에 주어진 순서대로 하나의 이진트리로 해당 수를 표현할 수 있다면 1을, 표현할 수 없다면 0을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.
 *
 * 이진트리를 수로 표현하는 방법을 알려줌
 * 문제는 수를 이진트리로 표현할 수 있는지 없는지를 알아내는 문제임
 *
 * 그러면 문제에서 제시한 내용을 역으로 하면 답이 나옴
 *
 * 1. 주어진 수를 이진수로 변환 Okay
 * 2. 이진수를 이진트리로 변환
 * 3. 이진트리를 수로 변환
 * 4. 변환한 수가 주어진 수와 같은지 확인
 *
 */
class Solution2 {
    public static void main(String[] args) {

    }

    public int[] solution(long[] numbers) {
        int[] answer = new int[numbers.length];

        for (int i = 0; i < numbers.length; i++) {
            long number = numbers[i];

            // 58 -> "111010"
            String binaryString = Long.toBinaryString(number);

            // binaryString을 트리로 만든다.

            // 트리를 중위탐색하여 문자열을 만든다.
        }

        return answer;
    }
}
