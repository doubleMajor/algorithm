```java
// 트리를 구성할 노드 선언
public class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
        left = null;
        right = null;
    }
}
```

void push(Node thisNode) : 노드를 트리에 추가하는 함수
int pop(Node thisNode) : 노드를 트리에서 제거하는 함수
boolean contain(Node thisNode) : 노드가 트리에 있는지 확인하는 함수
Node removeLastNode(Node thisNode) : 트리에서 마지막 노드를 제거하는 함수
boolean isSame(Node a, Node b) : 두 개의 노드가 같은 노드인지 확인하는 함수

```java
import java.util.LinkedList;
import java.util.Queue;

public class BinaryTree {
    Node node;
    int size;

    public BinaryTree() {
        node = null;
        size = 0;
    }

    public void push(Node addNode) {
        if (size == 0) {
            Node thisNode = addNode;
            node = thisNode;
        }
        else {
            Node thisNode = node;

            Queue<Node> queue = new LinkedList<Node>();
            queue.add(thisNode);

            while (!queue.isEmpty()) {
                Node temp = queue.poll();

                if (temp.left == null) {
                    temp.left = addNode;
                    break;
                }
                else {
                    queue.add(temp.left);
                }

                if (temp.right == null) {
                    temp.right = addNode;
                    break;
                }
                else {
                    queue.add(temp.right);
                }
            }
        }
        size++;
    }

    public int pop(Node thisNode) {
        if (contain(thisNode)) {
            Node lastNode = removeLastNode();

            if(node != null){
                if(isSame(node,thisNode)){
                    node.value = lastNode.value;
                }
                else{
                    Queue<Node> queueNode = new LinkedList<Node>();
                    queueNode.add(node);

                    while(!queueNode.isEmpty()){
                        Node temp = queueNode.poll();

                        if(temp.left != null){
                            if(isSame(temp.left,thisNode)){
                                temp.left.value = lastNode.value;
                                break;
                            }else{
                                queueNode.add(temp.left);
                            }
                        }

                        if(temp.right != null){
                            if(isSame(temp.right,thisNode)){
                                temp.right.value = lastNode.value;
                                break;
                            }
                        }
                    }
                }
            }
            size--;
            return 1;
        }
        return 0;
    }

    public boolean contain(Node thisNode) {
        boolean check = false;

        if (size != 0) {
            Queue<Node> queueNode = new LinkedList<Node>();
            queueNode.add(node);

            while (!queueNode.isEmpty()) {
                Node temp = queueNode.poll();

                if (isSame(temp,thisNode)) {
                    check = true;
                    break;
                }

                if (temp.left != null) {
                    queueNode.add(temp.left);
                }

                if (temp.right != null) {
                    queueNode.add(temp.right);
                }
            }
        }
        return check;
    }

    private Node removeLastNode() {
        Node last = node;

        if(size == 1){
            node = null;
        }
        else {
            Queue<Node> queueNode = new LinkedList<Node>();
            queueNode.add(last);

            while (!queueNode.isEmpty()) {
                Node temp = queueNode.poll();
                last = temp;

                if (temp.left != null) {
                    queueNode.add(temp.left);
                }

                if (temp.right != null) {
                    queueNode.add(temp.right);
                }
            }

            queueNode.add(node);

            while(!queueNode.isEmpty()){
                Node temp = queueNode.poll();

                if(temp.left != null){
                    if(isSame(temp.left,last)){
                        temp.left = null;
                        break;
                    }else{
                        queueNode.add(temp.left);
                    }
                }

                if(temp.right != null){
                    if(isSame(temp.right,last)){
                        temp.right = null;
                        break;
                    }else{
                        queueNode.add(temp.right);
                    }
                }
            }
        }
        return last;
    }

    private boolean isSame(Node a, Node b) {
        if (a.value == b.value && a.left == b.left && a.right == b.right) {
            return true;
        }
        return false;
    }

}
```