# 그래프

- 트리
    - 그래프의 한 형테
    - 루트가 존재
    - 아래로 차일드 노드들이 있음(진입지점이 하나)
    - 노드를 연결하는 엣지가 존재
    - 사이클이 없이 아래로만 흐르는 그래프(트리는 방향이 있으나 아래로만 흐르니 방향화살 표 생략)
    -

- 그래프
    - 엣지의 방향이 위아래로 자유롭거나 없을 수 있고
    - 진입지점이 여러개가 될 수 있음
    - 동일한 레벨의 노드와 연결이 되거나 자기 자신을 가리키기도 하며 엣지들이 연결되어 원형태가 되기도 함
    - 방향이 있는 그래프(Directed Graph) / 방향이 없는 그래프(Undirected Graph)
      ![img.png](이미지/img.png)
    - 엣지가 원형으로 연결된 그래프(Cyclic Graph)/ 원형연결이 없는 그래프(Acyclic)
      ![img_1.png](이미지/img_1.png)
    - 그래프를 표현하는 방법
        - Adjacency Matrix
            - 이차원배열(표)에 표현하는 방법
            - 서로 연결된 노드가 있으면 1, 아니면 0
              ![img_2.png](이미지/img_2.png)
        - Adjacency List
            - 배열에 노드들을 나열하고 관계를 링크드 리스트로 표현
            - ![img_3.png](이미지/img_3.png)
            - 방향성이 없는 그래프의 경우 엣지의 갯수가 m일때 총 노드의 갯수는 2m개가 생성됨(서로 연결이므로)


- 그래프를 검색하는 방법
    - Depth-First Search(DFS)
        - inorder, preorder, post order
    - Breadth-First Search(BFS)

- 그래프의 구현방법
    - 인접 행렬 : 2차원 배열을 사용 -- 메모리 ↑/ 속도 더 빠름
    - 인접 리스트 : 리스트를 사용 -- 메모리 ↓/ 속도 더 느림

    - 두 방식은 메모리와 속도 측면에서 구별이 됨. V가 노드의 개수, E가 간선의 개수라고 할 때, 인접행렬은 O(V^2)만큼의 메모리 공간이 필요한 반면, 인접 리스트를 이용할 때는 간선의 개수만큼인 O(E)만큼의 메모리 공간이 필요하다. 또한, 인접 행렬은 특정한 노드에서 다른 노드로 이어지는 간선의 비용을 O(1)의 시간으로 즉시 알 수 있는 반면, 인접 리스트는 O(V) 만큼의 시간이 소요된다는 차이가 있다. 코딩 테스트에서는 노드와 간선의 개수가 모두 많으면 우선 순위 큐를 사용하는 다익스트라 알고리즘을 이용하면 유리하고, 노드의 개수가 적으면 플로이드 워셜 알고리즘을 이용하는 것이 낫다.



